extern memory;
struct Node {
  Node *next;
  int val;
  double pad1, pad2, pad3, pad4;
};

function ObjNode() {
  this.next = null;
  this.val = 0;
  this.pad1 = this.pad2 = this.pad3 = this.pad4 = 0;
}

extern Date;

const int n = 25000;

function benchStruct() {
  let start = new Date();
  let Node *head;
  for (let int i = 0; i < n; ++i) {
    let Node *prev = head;
    head = new Node;
    head->next = prev;
    head->val = i;
  }

  let double sum = 0;
  for (let int i = 0; i < n; ++i) {
    let Node *prev = head;
    sum += head->val;
    head = head->next;
    delete prev;
  }

  return new Date() - start;
}

function benchObject() {
  let start = new Date();
  let head;
  for (let i = 0; i < n; ++i) {
    let prev = head;
    head = new ObjNode();
    head.next = prev;
    head.val = i;
  }

  let sum = 0;
  for (let i = 0; i < n; ++i) {
    sum += head.val;
    head = head.next;
  }

  return new Date() - start;
}

extern print;
if (typeof print === "undefined") {
  extern console;
  print = console.log;
}

// Warm up the JIT.
benchStruct(); benchStruct();
benchObject(); benchObject();

let dt;

dt = 0;
for (let i = 0; i < 25; ++i) {
  dt += benchStruct();
}
print("struct with 32 bytes of padding " + dt / 25);

dt = 0;
for (let i = 0; i < 25; ++i) {
  dt += benchObject();
}
print("object with 4 extra properties " + dt / 25);

let uint *x;
*x

let uint *leak = new uint;

// let m = memory
// if (m.memcheck.enabled){
//   print("\n")
//   print(m.memcheck.report())
// }
