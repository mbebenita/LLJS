<html>
<head>
  <title>*JS</title>
  <link rel="stylesheet" type="text/css" href="css/docs.css" />
  <link rel="stylesheet" type="text/css" href="css/idle.css" />
</head>

<script src="vendor/lib/codemirror.js"></script>
<link rel="stylesheet" href="vendor/lib/codemirror.css">
<script src="vendor/mode/javascript/javascript.js"></script>

<script>
  print = function (x) {
    console.info(x);
  }
</script>
<script src="jc/util.js"></script>
<script>
  var options = new OptionSet("option(s)");
</script>
<script src="vendor/jquery-1.6.4.js"></script>
<script src="jc/modules.js"></script>
<script src="jc/esprima.js"></script>
<script src="jc/escodegen.js"></script>
<script src="jc/compiler.js"></script>
<script src="jc/memory.js"></script>
<script src="jc/krmalloc.js"></script>
<body>
  <div class="container">
    <h1>*JS : Low-Level JavaScript</h1>
    <p>
      <b>*JS</b> is a typed dialect of JavaScript that offers a C-like type system with manual memory management.
      It compiles to JavaScript and lets you write memory-efficient and GC pause-free code less painfully, in short, *JS is the bastard child of JavaScript and C.
    </p>
    <p>
      *JS has 6 integral types: <tt>int -> i32</tt>, <tt>uint -> u32</tt>, <tt>i16</tt>, <tt>u16</tt>, <tt>i8</tt>, <tt>u8</tt>, which
      behave as they do in C, and two additional types: <tt>num</tt> (the JavaScript number type) and <tt>dyn</tt> (any type) which are used to interoperate with the JavaScript type system.
      In addition, *JS lets you define struct and pointer types.
    </p>

    <p>
      This is an interactive tutorial, code is compiled as you type.
      To execute the compiled code use <tt>Ctrl-R</tt> or <tt>Alt-/</tt>.
    </p>


<h4>Variables & Arithmetic</h4>
<p>
  Unlike JavaScript, *JS variable declarations are block scoped and can be annotated with type information.
  Untyped variable declarations are defaulted to the <tt>dyn</tt> type.
</p>

<pre class="example">
var x;               // Declare 'x' as dyn.

var int y;           // Declare 'y' as int.

y = (int) x;         // Assignment of 'x' to 'y' requires an explicit cast.

var int z = y + 1;   // Although 'y' is of type int, the binary expression
                     // y + 1 is of type num and requires an implicit cast.

var uint w = z;      // Unsigned integer types are suported but are discouraged
                     // because JavaScript engines usually store numbers that
                     // are larger than max signed int in doubles rather than
                     // 32 bit ints.

timer.begin("Empty For loop with signed integers.");

for (var int i = 0; i < 50000000; ++i) { }

timer.begin("Empty For loop with unsigned integers.");

for (var uint i = 0; i < 50000000; ++i) { }

timer.begin("Empty For loop with untyped integers.");

for (var i = 0; i < 50000000; ++i) { }


</pre>

<p>
  *JS lets you use pointers.
</p>

<pre class="example">
var int x = 42;      // Declare 'x' as int and assign '42' to it.

var int *y = &x;     // Declare 'y' as a pointer to int and assign it the address
                     // of x. Since JavaScript doesn't allow taking references to
                     // to variables, we allocate 'x' on an emulated stack.

var int **z = &y;    // Declare 'z' as a pointer to a pointer to int.

*y = 1;              // Assign to the variable pointed to by 'y'.

**z = ***(&z);       // You can get as fancy as you want.
</pre>

<h4>Functions</h4>

<p>
  *JS lets you type functions as well. A typed function is any function that has
  its return value or at least one of its arguments typed.
</p>

<pre class="example">

// Declare 'foo' as dyn, normal JavaScript function.
function foo () { }

// Declare 'bar' as () -> void, typed *JS function.
function void bar () { }

// Declare 'baz' as (int, int*) -> void, typed *JS function with typed arguments.
function void baz (int x, int *y) { }

// Declare 'car' as (int, dyn, int x) -> dyn, typed *JS function with mixed typed
// and untyped arguments.
function car (int x, y, int z) { }

// Call 'car', arguments are coerced to the callee's parameter types.
car("123", 2, 123.456);

// The type system is not smart enough to track types that leak into the dynamic
// type system. Safety is your responsability.
var val = car;

// Calling 'var' is not safe.
val("123", 2, 123.456);

</pre>

<p>
  For example, you can implement a <tt>swap</tt> function in *JS as follows:
</p>

<pre class="example">

function void swap(int *a, int *b) {
  var int t = *a;
  *a = *b;
  *b = t;
}

var int x = 1, y = 2;

swap(&x, &y);

trace("x = " + x + ", y = " + y);

</pre>


<h4>Objects and Memory</h4>

<p>
  *JS has two object models: C style <tt>malloc</tt> and <tt>free</tt>, and the JavaScript object model.
  Why would you ever want to mange your memory explicitly when the JavaScript garbage collector already does the work for you.
  <!--  (*JS offers limited support for interoperability between the two, for now at least.) -->
  Well imagine you wanted to write a linked list in JavaScript.
  You would probably chain a sequence of objects together, like so:
</p>
<pre>
 var head = {value: 0, next: null}, tail = head;

 function add(value) {
   var next = {value: value, next: null};
   tail.next = next;
   tail = next;
 }
</pre>
    <p>
      This is inefficient for several reasons. Objects in JavaScript are not cheap, they need to carry around lots of extra information and can be
      many times larger than their C style counterparts, moreover property access is slow. In *JS you can write a much more efficient linked list
      using pointers and structs. The code below uses <tt>malloc</tt> to allocate memory, which is modeled using typed arrays.
      (<tt>I32</tt> and <tt>U32</tt> are typed signed/unsigned views over one large array buffer.)
      With great power comes great responsibility, so what is malloc'ed must be freed, even in JavaScript.
    </p>

<pre class="example">
struct Node {
  var Node *next;
  var int value;
}

var Node *head = new Node, *tail = head;

function void add (int value) {
  var Node * next = new Node;
  next->value = value;
  tail->next = next;
  tail = next;
}
</pre>
    <p>
      <tt>malloc</tt> and <tt>free</tt> are themselves implemented in *JS, see proof below:
    </p>
<pre class="example">
const MB = 1024 * 1024;
const SIZE = 32 * MB;
const STACK_SIZE = 2 * MB;
const HEAP_SIZE = SIZE - STACK_SIZE;

var I4, U4;

/*
   +---------------+ -
 0 | Heap  Pointer |
 1 | Stack Pointer |
   +---------------+ <- Heap Pointer (HP)
   |               |
   |               | |
   |     HEAP      | | Malloc Region
   |               | v
   |               |
   +---------------+
   |               |
   |               | ^
   |     STACK     | |
   |               | |
   |               |
   +---------------+ <- Stack Pointer (SP)
*/

function int * memoryCopy(int *dst, int *src, int length) {
  for (var int i = 0; i < length; ++i) {
    *dst++ = *src++;
  }
  return dst;
}


/* K & R Malloc */

struct Header {
  var Header * next;
  var uint size;
}

var Header * base = NULL;
var Header * freep = NULL;

function resetMemory() {
  var M = exports.M = new ArrayBuffer(SIZE);
  exports.U1 = new Uint8Array(M);
  exports.I1 = new Int16Array(M);
  exports.U2 = new Uint16Array(M);
  exports.I2 = new Int16Array(M);
  U4 = exports.U4 = new Uint32Array(M);
  I4 = exports.I4 = new Int32Array(M);
  exports.F4 = new Float32Array(M);
  exports.F8 = new Float64Array(M);

  U4[0] = 4;
  U4[1] = SIZE;

  base = (Header *)2;
  freep = NULL;
}

resetMemory();

function void * sbrk(int nBytes) {
  var int nWords = nBytes / sizeof (u32);
  if (U4[0] + nWords > HEAP_SIZE) {
    trace("Out of Memory");
    return NULL;
  }
  var void * address = (int *)U4[0];
  U4[0] += nWords;
  return address;
}

var uint nUnitsMin = 1024;

function Header * morecore(int nUnits) {
  if (nUnits < nUnitsMin) {
    nUnits = nUnitsMin;
  }
  var void * buffer = sbrk(nUnits * sizeof (Header));

  if (buffer === 0) {
    return NULL;
  }
  var Header * header = (Header *)buffer;
  header->size = nUnits;
  free(header + 1);
  return freep;
}

function void * malloc(int nBytes) {
  var Header *p, *prevp;
  var int nUnits = ((nBytes + sizeof(Header) - 1) / sizeof(Header)) + 1;

  if ((prevp = freep) === NULL) {
    base->next = freep = prevp = base;
    base->size = 0;
  }
  for (p = prevp->next; true; prevp = p, p = p->next) {
    if (p->size >= nUnits) {
      if (p->size === nUnits) {
        prevp->next = p->next;
      } else {
        p->size -= nUnits;
        p += p->size;
        p->size = nUnits;
      }
      freep = prevp;
      return p + 1;
    }
    if (p === freep) {
      if ((p = morecore(nUnits)) == NULL) {
        return NULL;
      }
    }
  }
  return NULL;
}

function void free(void *ap) {
  var Header *bp = (Header *)ap - 1, *p;
  for (p = freep; !(bp > p && bp < p->next); p = p->next) {
    if (p >= p->next && (bp > p || bp < p->next)) {
      break;
    }
  }
  if (bp + bp->size === p->next) {
    bp->size += p->next->size;
    bp->next = p->next->next;
  } else {
    bp->next = p->next;
  }
  if (p + p->size == bp) {
    p->size += bp->size;
    p->next = bp->next;
  } else {
    p->next = bp;
  }
  freep = p;
}
</pre>
</div>

<script>
/*
var myCodeMirror = CodeMirror(document.body, {
  value: "function myScript(){return 100;}\n",
  mode:  "javascript"
});
*/
</script>

<script>
var id = 0;
$('.example').replaceWith(function() {
  var src = this.innerHTML;
  var lineCount = src.split("\n").length;
  return '<table class="example"><tr><td><textarea id="ex:' + id + ':source" class="jcCode" rows="' + lineCount + '" spellcheck="false">' + src + '</textarea></td><td valign="top"><pre id="ex:' + id++ + ':result" class="jcResult"></pre></td></tr></table>'
  // <div class="minibutton ok run" title="Ctrl-Enter">Run</div>
});

var lastMarker;
function compileExample(id) {
  if (lastMarker) {
    this.clearMarker(lastMarker);
  }
  var number = id.split(":")[1];
  var result = document.getElementById("ex:" + number + ":result");
  try {
    var node = esprima.parse(this.getValue(), {loc: true});
    compile(node, "EX_" + number);
    result.innerHTML = escodegen.generate(node, {base: "", indent: "  "});
  } catch (x) {
    result.innerHTML = x.message;
    if (x.lineNumber !== undefined) {
      lastMarker = this.setMarker(x.lineNumber - 1, "<span style=\"color: #900\">o</span> %N%");
    }
  }
}

var extern = {};

var Timer = (function () {
  function timer() {
    this.name = null;
    this.start = null;
  }

  timer.prototype.begin = function (name) {
    if (this.start) {
      if (this.name) {
        extern.trace("Timer: " + (new Date() - this.start) + " ms: " + this.name);
      } else {
        extern.trace("Timer: " + (new Date() - this.start) + " ms.");
      }
    }
    this.start = new Date();
    this.name = name;
  };

  return timer;
})();

var timer;
var trace;

function executeExample(id) {
  var number = id.split(":")[1];
  var result = document.getElementById("ex:" + number + ":result");
  try {
    require("memory").resetMemory();

    timer = new Timer();

    result.innerHTML = "";

    extern.trace = trace = function (x) {
      result.innerHTML += x + "\n";
    };

    var start = new Date();
    var node = esprima.parse(this.getValue(), {loc: true});
    result.innerHTML += "Parser: " + (new Date() - start) + " ms, ";

    start = new Date();
    node = compile(node, "EX_" + number);
    result.innerHTML += "Compiler: " + (new Date() - start) + " ms, ";

    start = new Date();
    var code = escodegen.generate(node, {base: "", indent: "  "});
    result.innerHTML += "Code Generator: " + (new Date() - start) + " ms.\n";
    result.innerHTML += "-----------------------------------------------------\n";

    start = new Date();
    new Function (code)();
    var fn = modules["EX_" + number];
    fn();

    timer.begin(null);
    result.innerHTML += "-----------------------------------------------------\n";
    result.innerHTML += "Executed in : " + (new Date() - start) + " ms.";

  } catch (x) {
    result.innerHTML = x.message;
  }
}

$('.jcCode').each(function() {
  var id = this.id;
  var cm = CodeMirror.fromTextArea(this, {
    tabSize: 2,
    lineNumbers: true,
    gutter: true,
    onChange: function () {
      compileExample.call(cm, id);
    },
    extraKeys: {
      "Ctrl-R": function () {
        executeExample.call(cm, id);
      },
      "Cmd-Enter": function () {
        executeExample.call(cm, id);
      }
    }
  });
  compileExample.call(cm, id);
});

</script>
</body>
</html>
